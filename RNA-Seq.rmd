---
title: "Reporte de Prácticas 1"
author: Ramos Galguera Johana Itzel, Marín Peralta Alejandro Efraín, Talavera Cruz
  María Fernanda
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float:
      toc_collapsed: true
    toc_depth: 3
    number_sections: true
    theme: lumen
---

# Abstract

# Introduction

# Methods

First of all, a new directory in the DNA High-Performance Computing Cluster
was created, which is

```{bash directory, eval=FALSE}
/mnt/Timina/bioinfoII/amarin/RNAseq2/
```

This directory has the next organization:

```{bash structure, eval=FALSE}
|-data/           # Directory to download the raw data
|-data_trimmed/   # Directory to save the post-QC data
|-kallisto_out/   # Directory to save the kallisto outputs
|-QC/             # Directory to perform raw QC
|-QC_trimmed/     # Directory to perform QC on the trimmed data
|-scripts/        # Some scripts used to send jobs
```


## Download

The dataset choose to analysis has de GEO Accession 
[GSE91061](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE91061). 
Since downloading from the NCBI may be difficult and quite technical, it was 
choosen to use the European mirror, the 
[European Nucleotide Archive](https://www.ebi.ac.uk/ena/browser/home) from the
EMBL-EBI. By browing on the GEO web page, we see that the data are from the 
BioProject 
[PRJNA356761](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA356761). We use that
ID to search on ENA. 

![](images/ENA_screenshot.png)

Due the fact that the are a lot of file needed to be downloaded, we use the 
web application 
[SRA Explorer](https://sra-explorer.info/) to get a script to get the bulk
download.

![](images/SRA-Explorer_screenshot.png)
We then select all the files and click on "Add to collection". After that, we
see our saves datasets and select the bash script for downloading FastQ files
option. We save the script with the name ```downloadScript.sh```, and save it in
the HPCC, in the ```//data/``` directory.

Then, we send a job using the script. It lasted around 5 days.


## Raw Quality Control

Once the data is ready, we perform quality control. We just send a job using 
fastqc with all the ```fastq``` files via a wildcard:

```{bash fastqc, eval=FALSE}
fastqc /mnt/Timina/bioinfoII/amarin/RNAseq2/data/*fastq.gz -o /mnt/Timina/bioinfoII/amarin/RNAseq2/QC
```

Then, we used multiqc to visualize all the samples at once:

```{bash multiqc, eval=FALSE}
multiqc /mnt/Timina/bioinfoII/amarin/RNAseq2/QC -o /mnt/Timina/bioinfoII/amarin/RNAseq2/QC
```

This allowed us to see some irregularities. First, the first to nucleotides of
each read had a smaller mean quality score, compared to the rest of the read.

![](QC/raw_mean_quality.png)

Besides, in the heatmap, the base sequence sequence content seemed to be biased
on the first base pairs of the read.

![](QC/raw_base_content_heatmap.png)

All the samples resembled more or less the next percentage of base content.

![](QC/raw_base_content.png)

Nevertheless, MultiQC didn't detect any adapter content. Based on that, we decided
to trimm the first 12 nucleotides of each pair.


## Trimming

We send a job in the  ```//data/``` directory with a script using the software
Trimmomatic:

```{bash trimming, eval=FALSE}
for i in *_1.fastq.gz;
	do echo
  	trimmomatic PE -threads 40 -phred33 -trimlog trim.log \
    	$i "${i%_1.fastq.gz}_2.fastq.gz" \
    	../data_trimmed/"${i%_1.fastq.gz}_1_trimmed.fastq.gz" \
    	../data_trimmed/"${i%_1.fastq.gz}_1_unpaired.fastq.gz" \
    	../data_trimmed/"${i%_1.fastq.gz}_2_trimmed.fastq.gz" \
    	../data_trimmed/"${i%_1.fastq.gz}_2_unpaired.fastq.gz" \
    	HEADCROP:12
  done
```

Here we just cut the first 12 nucleotides of each read and create a ```trim.log```
log file by the use of 40 threads. We know that the Phred score are based on 
ASCII 33 because previously we found a ```#``` symbol on the reads.

This job took a couple of days.

## Trimmed Quality Control

Once the data was trimmed, we did one more time the quality control.

```{bash trimmed_qc, eval=FALSE}
fastqc /mnt/Timina/bioinfoII/amarin/RNAseq2/data_trimmed/*fastq.gz \
  -o /mnt/Timina/bioinfoII/amarin/RNAseq2/QC_trimmed
multiqc /mnt/Timina/bioinfoII/amarin/RNAseq2/QC_trimmed \
  -o /mnt/Timina/bioinfoII/amarin/RNAseq2/QC_trimmed
```

This time, the quality of the first pair bases was better.

![](QC_trimmed/trimmed_quality_mean.png)

Besides, the "per base sequence content" was less biased:

![](QC_trimmed/trimmed_base_content_heatmap.png)

Each sample was more homogeneous.

![](QC_trimmed/trimmed_base_content.png)

Besides, other indicators, such as the "per base N content" and "per sequence
GC content" performed better.


## Pseudoaligment to reference genome

Once the data was ready, we decided to generate count matrices using Kallisto.
To perform this, we first need a reference transcriptome. We choose the latest
version available at 
[GENCODE](https://www.gencodegenes.org/human/), which is the release 43.
The file was downloaded at the parent directory of this project:

```{bash gencode, eval = FALSE}
wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_43/gencode.v43.transcripts.fa.gz
```

Then, generated the kallisto index:


```{bash index, eval = FALSE}
kallisto index -i /mnt/Timina/bioinfoII/amarin/RNAseq2/kallisto_out/Hs_ref.kidx \
  /mnt/Timina/bioinfoII/amarin/RNAseq2/gencode.v43.transcripts.fa.gz
```

Then, we used a bash script to perform the quantification with all the samples.


```{bash pseudo, eval=FALSE}
for file in /mnt/Timina/bioinfoII/amarin/RNAseq2/data_trimmed/*_1_trimmed.fastq.gz
do
    op=$(basename $file | cut -c-10 )         
    file2=$(echo $file | sed 's/_1_/_2_/')  
    mkdir /mnt/Timina/bioinfoII/amarin/RNAseq2/kallisto_out/${op}
    
    kallisto quant -i /mnt/Timina/bioinfoII/amarin/RNAseq2/kallisto_out/Hs_ref.kidx \
    -o /mnt/Timina/bioinfoII/amarin/RNAseq2/kallisto_out/${op} \
    --threads 40 $file $file2
done
```


## Differencial Expresion 

For the differential expression analysis we used 

```{r libraries, message=FALSE, warning=FALSE, include=FALSE}
library(tximport)
library(tidyverse)
library(DESeq2)
library(ggplot2)
library(ggrepel) # libreria que evita el overlap de texto en labels
library(rhdf5)
library(GenomicFeatures)
library(dplyr)
library(biomaRt)
library(gprofiler2)
library(ComplexHeatmap)
library(genefilter)
library(clusterProfiler)
library(AnnotationDbi)
library(org.Hs.eg.db)
library(ggupset)
library(enrichplot)
```

### Data importation

First, we imported the kallisto quantification tables to a local computer.
Then, we created a tx2gene table, which maps annotated genes with transcripts.
To do this, we used the Bioconductor package biomaRt.


```{r ensembl, warning=FALSE, message = FALSE}
ensembl = useEnsembl(biomart="ensembl", dataset="hsapiens_gene_ensembl")


tx2gene = getBM(attributes=c('ensembl_transcript_id','ensembl_gene_id'), 
                   mart = ensembl)
```

Next, we import the quantification table to the R environment. To do this, we
use the Bioconductor package rhdf5

```{r kallisto-import}
## Paths to h5 archives
files = file.path(list.dirs("./kallisto_data", recursive = FALSE),
                  "abundance.h5")
names(files) = str_extract(files, "SRR\\d+")

## Importation
txi.kallisto.tsv = tximport(files, type = "kallisto", tx2gene = tx2gene,
                            ignoreAfterBar = TRUE, ignoreTxVersion=TRUE)


head(txi.kallisto.tsv$counts)
```


Next, we create a metadata table to know the treatment for each SRA sample. 
Since it wasn't available on SRA Run Selector web page, we needed to manually
create it.

```{r metadata}
## Metadata importation to R
meta = read.csv("./metadata.csv", header = FALSE)
samples = column_to_rownames(meta, var = "V1")
```

Now, we create a DESeq2 dataset-like object, called DESeqDataSet, using the
imported counts, sample names and metadata table.

```{r dds}
dds = DESeqDataSetFromTximport(txi.kallisto.tsv,
                               colData = samples,
                               design = ~V2)
```






### Exploratory Analysis


### Differencial Expresion Analysis


## Gene Ontology Enrichment





# Results


# Conclusions


# References


# Session Information

```{r session-info}
sessionInfo()
```





